---
title: "Results from graph heuristic"
author: "Franco Peschiera"
date: "6/18/2020"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
setwd('../')
source('graph_reports/export_results.R')

solver <- list(prise_srv3_20200605_good='HEUR', 
               serv_cluster1_20200609_good='HEUR', 
               serv_cluster1_20200609_4='HEUR',
               serv_cluster1_20200616='HEUR',
               serv_cluster1_20200617='HEUR',
               serv_cluster1_20200617_2='HEUR', 
               serv_cluster1_20200617_3='HEUR')

```

This is a summary of the tests done so far. I've only used 5 instances per scenario (too few, maybe?) and a limit of 20 minutes.

## On the instances

They have been generated by the same method as the others. I have changed the possibilities of frequency of maintenances so there are less possibilities of maintenance than before (the window to make the maintenance is smaller, the max frequency is the same). The main reason is that since the original mathematical model assumes only two maintenances and the generated graphs are agnostic to this (1, 2, 3, or more maintenances), I can not permit a frequency of less than half the planning horizon without allowing the possibility of having compatibility issues between the two methods. Example: in a horizon of 90 periods, having a maintenance distance of 40 permits having 3 maintenances, one at the beginning, one in the middle, one at the end. This is impossible in the model but possible as a graph solution and causes problems when moving solutions from one to the other.


## The current heuristic

"short" = shortest path algorithm to generate a new pattern for a single aircraft using the generated graph. Usually weights depend on the current solution and the time window is the whole planning period.   
"classic-mip" = solve the whole mip problem by fixing everything that happens outside a "time window" + "set of aircraft" combination. This uses the OR Spectrum MIP without the pseudo-cuts.

The last version of the algorithm, tested below does the following:

1. Create graphs.
2. Finds an initial solution by adding one aircraft at a time using "short".
3. Iterate until time limit or iteration limit:
    1. Randomly picking one of two: "short" or "classic-mip".
    2. Generate a random candidate:
        3. For "short", this is a random aircraft and the whole planning period.
        4. For "classic-mip" this is 30-60 aircraft and 20-66 periods, stopping at 30s or 2% gap.
    3. Keep the solution or not depending on some simulated annealing logic (which is almost "keep if better").

## Quality of the initial solution

Both solvers and the graph method find a feasible solution relatively fast (fast meaning as soon as the searching starts).
But the initial solution obtained by "short" is quite good compared with the MIPs.

In the Table below, for each instance of each scenario, the percentage difference between the initial solution and the best known one for each instance $(initial- best)/best$. In case of the hybrid methods, they sometimes obtain a solution around 2-5 times (200%- 500%) away from the best known one before solving any model. CPLEX does a bad initial solution.

```{r initial}
exps <- c('serv_cluster1_20200617_3', 'serv_cluster1_20200617', 'serv_cluster1_20200610')
exp_names <- c('graph_50', 'graph_10', 'cplex')
initial <- compare_initial(exps, exp_names, solver=solver)
initial %>% kable(format.args = list(big.mark = "."))
```

## Analyze on pre-processing time impact

For the "pure" models we count the time inside the solver, which comes after the pre-processing and model building. This usually takes very little (several seconds, less than 20).

For the hybrid models, we count from the start: we count the mip model pre-processing (which is the same: we do it only once), we count the mip model building (which we do several times but does not take too long). More importantly, we count the time to build the graphs. This depends on the size of the graphs and can take between 60 and 300 seconds. 

The size of the graph depends on the initial data: aircraft that are in bad shape are going to have two maintenances and so will need a bigger graph (with more possibilities). The size can be reduced by rounding down the nodes with respect to the remaining flight time (`rft`) of the aircraft. This is, in effect, reducing the valid space of the solution. Of course, this will help both during the generation (less nodes= less time to build) and the later exploitation of the graph (the shortest path will be faster, the assignment of weights will be faster too). On the other hand, we will rely more on the MIP to improve solutions, because it will obtain some patterns that the graph is unable to reach.

In the Figure, `graph_10` means we rounded all nodes to the nearest 10 in terms of `rft`. `graph_50` is more aggressive in reducing the size of the graph. Also, I took the first minute to improve the scale.

```{r pre_processing, out.width='100%'}
exps <- c('serv_cluster1_20200617_3', 'serv_cluster1_20200617', 'serv_cluster1_20200610')
exp_names <- c('graph_50', 'graph_10', 'cplex')
progress <- get_progress(exps, exp_names, solver=solver)
progress %<>% filter(Time>60)
draw_progress(progress, num_aircraft_filt=60, log_scale_y=FALSE)
```

## Comparison on very large datasets

In large datasets, there is not much difference between the approaches in the solution after 20 minutes.

```{r large}
exps <- c('serv_cluster1_20200616', 'serv_cluster1_20200615')
exp_names <- c('graph', 'cplex')
large <- get_summary_table(exps, exp_names)
large %>% kable(format.args = list(big.mark = "."))
```
 
And the progress. These results need to be updated with a better version of the graph algorithm that initializes a little faster and obtains better initial solutions.

```{r large_progress, out.width='100%'}
exps <- c('serv_cluster1_20200616', 'serv_cluster1_20200615')
exp_names <- c('graph', 'cplex')
progress <- get_progress(exps, exp_names, solver=solver)
progress %<>% filter(Time>60)
draw_progress(progress, num_aircraft_filt=105, log_scale_y=FALSE)
```

## Using CBC or CPLEX

Apparently there is not a great gain in using CBC or CPLEX for solving the MIP subproblem. This is probably caused by the fact that the MIP problems are relatively small.

```{r cbc}
exps <- c('serv_cluster1_20200617_3', 'serv_cluster1_20200617_2', 'serv_cluster1_20200610')
exp_names <- c('graph_cbc', 'graph_cplex', 'cplex')
get_summary_table(exps, exp_names) %>% kable()
```

And the progress:

```{r cbc_progress, out.width='100%'}
exps <- c('serv_cluster1_20200617_3', 'serv_cluster1_20200617_2', 'serv_cluster1_20200610')
exp_names <- c('graph_cbc', 'graph_cplex', 'cplex')
progress <- get_progress(exps, exp_names, solver=solver)
progress %<>% filter(Time>60)
draw_progress(progress, num_aircraft_filt=75, log_scale_y=FALSE)
```

